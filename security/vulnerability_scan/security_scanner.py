"""
Security Scanner for Performance & Security Testing Lab
Provides automated security vulnerability scanning capabilities
"""

import requests
import json
import time
import subprocess
import sys
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from pathlib import Path
from urllib.parse import urljoin, urlparse

from helpers.logger import PerformanceSecurityLogger
from config.settings import SECURITY_CONFIG, TEST_TARGETS_CONFIG

# Initialize logger
logger = PerformanceSecurityLogger("SecurityScanner")


@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    id: str
    name: str
    description: str
    severity: str  # LOW, MEDIUM, HIGH, CRITICAL
    category: str  # SQL_INJECTION, XSS, CSRF, etc.
    url: Optional[str] = None
    parameter: Optional[str] = None
    evidence: Optional[str] = None
    remediation: Optional[str] = None
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None


@dataclass
class SecurityHeaders:
    """Security headers analysis"""
    url: str
    headers: Dict[str, str]
    missing_headers: List[str]
    weak_headers: List[str]
    score: int = 0


class SecurityScanner:
    """Main security scanner class"""
    
    def __init__(self, target_url: str):
        self.target_url = target_url
        self.vulnerabilities: List[Vulnerability] = []
        self.security_headers: List[SecurityHeaders] = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SecurityScanner/1.0'
        })
    
    def scan_security_headers(self) -> List[SecurityHeaders]:
        """Scan for security headers"""
        logger.step("Scanning security headers")
        
        try:
            response = self.session.get(self.target_url, timeout=10)
            
            headers_analysis = SecurityHeaders(
                url=self.target_url,
                headers=dict(response.headers),
                missing_headers=[],
                weak_headers=[]
            )
            
            # Check for required security headers
            required_headers = SECURITY_CONFIG.REQUIRED_SECURITY_HEADERS
            
            for header in required_headers:
                if header not in response.headers:
                    headers_analysis.missing_headers.append(header)
                    logger.security_alert(
                        f"Missing security header: {header}",
                        severity="WARNING",
                        category="CONFIG",
                        details={"url": self.target_url}
                    )
                else:
                    # Check header values for common misconfigurations
                    value = response.headers[header]
                    if self._is_weak_header_value(header, value):
                        headers_analysis.weak_headers.append(header)
                        logger.security_alert(
                            f"Weak security header configuration: {header} = {value}",
                            severity="MEDIUM",
                            category="CONFIG",
                            details={"url": self.target_url, "header": header, "value": value}
                        )
            
            # Calculate security score
            headers_analysis.score = self._calculate_header_score(headers_analysis)
            
            self.security_headers.append(headers_analysis)
            logger.success(f"Security headers scan completed for {self.target_url}")
            
            return [headers_analysis]
            
        except Exception as e:
            logger.error(f"Failed to scan security headers for {self.target_url}", e)
            return []
    
    def _is_weak_header_value(self, header: str, value: str) -> bool:
        """Check if a security header has a weak configuration"""
        weak_configs = {
            "X-Frame-Options": ["ALLOWALL", "ALLOW-FROM *"],
            "X-Content-Type-Options": ["nosniff", "NOSNIFF"],
            "X-XSS-Protection": ["0", "false"],
            "Strict-Transport-Security": ["max-age=0", "max-age=1"],
            "Content-Security-Policy": ["unsafe-inline", "unsafe-eval", "*"],
            "Referrer-Policy": ["unsafe-url", "no-referrer-when-downgrade"]
        }
        
        if header in weak_configs:
            for weak_value in weak_configs[header]:
                if weak_value.lower() in value.lower():
                    return True
        
        return False
    
    def _calculate_header_score(self, headers_analysis: SecurityHeaders) -> int:
        """Calculate security score based on headers (0-100)"""
        base_score = 100
        missing_penalty = 15
        weak_penalty = 10
        
        score = base_score
        score -= len(headers_analysis.missing_headers) * missing_penalty
        score -= len(headers_analysis.weak_headers) * weak_penalty
        
        return max(0, score)
    
    def scan_sql_injection(self) -> List[Vulnerability]:
        """Scan for SQL injection vulnerabilities"""
        logger.step("Scanning for SQL injection vulnerabilities")
        
        vulnerabilities = []
        test_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' AND 1=1 --",
            "1' AND 1=2 --"
        ]
        
        # Test common endpoints
        test_endpoints = [
            "/search?q=",
            "/login?username=",
            "/product?id=",
            "/user?id="
        ]
        
        for endpoint in test_endpoints:
            for payload in test_payloads:
                try:
                    test_url = urljoin(self.target_url, endpoint + payload)
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for SQL error patterns
                    if self._detect_sql_error(response.text):
                        vuln = Vulnerability(
                            id=f"SQL_INJ_{len(vulnerabilities)}",
                            name="SQL Injection",
                            description=f"Potential SQL injection found in {endpoint}",
                            severity="HIGH",
                            category="SQL_INJECTION",
                            url=test_url,
                            parameter=endpoint.split("=")[0] + "=",
                            evidence=payload,
                            remediation="Use parameterized queries and input validation",
                            cwe_id="CWE-89",
                            cvss_score=8.5
                        )
                        vulnerabilities.append(vuln)
                        
                        logger.security_alert(
                            f"SQL injection vulnerability detected in {endpoint}",
                            severity="HIGH",
                            category="SQL_INJECTION",
                            details={"url": test_url, "payload": payload}
                        )
                
                except Exception as e:
                    logger.warning(f"Failed to test SQL injection for {endpoint}: {str(e)}")
        
        self.vulnerabilities.extend(vulnerabilities)
        logger.success(f"SQL injection scan completed. Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
    
    def _detect_sql_error(self, response_text: str) -> bool:
        """Detect SQL error messages in response"""
        sql_error_patterns = [
            "sql syntax",
            "mysql_fetch_array",
            "ora-",
            "sql server",
            "postgresql",
            "sqlite",
            "database error",
            "syntax error",
            "unclosed quotation mark"
        ]
        
        response_lower = response_text.lower()
        return any(pattern in response_lower for pattern in sql_error_patterns)
    
    def scan_xss(self) -> List[Vulnerability]:
        """Scan for Cross-Site Scripting (XSS) vulnerabilities"""
        logger.step("Scanning for XSS vulnerabilities")
        
        vulnerabilities = []
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "'><script>alert('XSS')</script>"
        ]
        
        # Test common parameters
        test_parameters = [
            "search?q=",
            "comment?text=",
            "message?content=",
            "name?value="
        ]
        
        for param in test_parameters:
            for payload in xss_payloads:
                try:
                    test_url = urljoin(self.target_url, param + payload)
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vuln = Vulnerability(
                            id=f"XSS_{len(vulnerabilities)}",
                            name="Cross-Site Scripting (XSS)",
                            description=f"Potential XSS found in {param}",
                            severity="HIGH",
                            category="XSS",
                            url=test_url,
                            parameter=param.split("=")[0] + "=",
                            evidence=payload,
                            remediation="Implement proper input validation and output encoding",
                            cwe_id="CWE-79",
                            cvss_score=7.5
                        )
                        vulnerabilities.append(vuln)
                        
                        logger.security_alert(
                            f"XSS vulnerability detected in {param}",
                            severity="HIGH",
                            category="XSS",
                            details={"url": test_url, "payload": payload}
                        )
                
                except Exception as e:
                    logger.warning(f"Failed to test XSS for {param}: {str(e)}")
        
        self.vulnerabilities.extend(vulnerabilities)
        logger.success(f"XSS scan completed. Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
    
    def scan_csrf(self) -> List[Vulnerability]:
        """Scan for Cross-Site Request Forgery (CSRF) vulnerabilities"""
        logger.step("Scanning for CSRF vulnerabilities")
        
        vulnerabilities = []
        
        # Test for CSRF protection
        csrf_endpoints = [
            "/change-password",
            "/update-profile",
            "/delete-account",
            "/transfer-money"
        ]
        
        for endpoint in csrf_endpoints:
            try:
                test_url = urljoin(self.target_url, endpoint)
                
                # Test without CSRF token
                response = self.session.post(test_url, data={"action": "test"}, timeout=10)
                
                # If request succeeds without CSRF token, it might be vulnerable
                if response.status_code == 200 and "error" not in response.text.lower():
                    vuln = Vulnerability(
                        id=f"CSRF_{len(vulnerabilities)}",
                        name="Cross-Site Request Forgery (CSRF)",
                        description=f"Potential CSRF vulnerability in {endpoint}",
                        severity="MEDIUM",
                        category="CSRF",
                        url=test_url,
                        evidence="Request succeeded without CSRF token",
                        remediation="Implement CSRF tokens and validate them on all state-changing requests",
                        cwe_id="CWE-352",
                        cvss_score=6.5
                    )
                    vulnerabilities.append(vuln)
                    
                    logger.security_alert(
                        f"CSRF vulnerability detected in {endpoint}",
                        severity="MEDIUM",
                        category="CSRF",
                        details={"url": test_url}
                    )
            
            except Exception as e:
                logger.warning(f"Failed to test CSRF for {endpoint}: {str(e)}")
        
        self.vulnerabilities.extend(vulnerabilities)
        logger.success(f"CSRF scan completed. Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
    
    def scan_authentication(self) -> List[Vulnerability]:
        """Scan for authentication vulnerabilities"""
        logger.step("Scanning for authentication vulnerabilities")
        
        vulnerabilities = []
        
        # Test for weak authentication
        auth_endpoints = [
            "/login",
            "/admin/login",
            "/api/auth"
        ]
        
        weak_passwords = [
            "admin",
            "password",
            "123456",
            "qwerty",
            "test"
        ]
        
        for endpoint in auth_endpoints:
            for password in weak_passwords:
                try:
                    test_url = urljoin(self.target_url, endpoint)
                    auth_data = {
                        "username": "admin",
                        "password": password
                    }
                    
                    response = self.session.post(test_url, data=auth_data, timeout=10)
                    
                    # Check if login succeeded with weak password
                    if "dashboard" in response.text.lower() or "welcome" in response.text.lower():
                        vuln = Vulnerability(
                            id=f"AUTH_{len(vulnerabilities)}",
                            name="Weak Authentication",
                            description=f"Weak password accepted in {endpoint}",
                            severity="HIGH",
                            category="AUTHENTICATION",
                            url=test_url,
                            evidence=f"Password '{password}' was accepted",
                            remediation="Implement strong password policies and rate limiting",
                            cwe_id="CWE-521",
                            cvss_score=7.0
                        )
                        vulnerabilities.append(vuln)
                        
                        logger.security_alert(
                            f"Weak authentication detected in {endpoint}",
                            severity="HIGH",
                            category="AUTHENTICATION",
                            details={"url": test_url, "weak_password": password}
                        )
                        break  # Don't test more passwords for this endpoint
                
                except Exception as e:
                    logger.warning(f"Failed to test authentication for {endpoint}: {str(e)}")
        
        self.vulnerabilities.extend(vulnerabilities)
        logger.success(f"Authentication scan completed. Found {len(vulnerabilities)} vulnerabilities")
        return vulnerabilities
    
    def run_full_scan(self) -> Dict[str, Any]:
        """Run a comprehensive security scan"""
        logger.start_test("Security Vulnerability Scan", "security")
        
        scan_results = {
            "target_url": self.target_url,
            "scan_timestamp": time.time(),
            "vulnerabilities": [],
            "security_headers": [],
            "summary": {}
        }
        
        # Run all scans
        scan_results["security_headers"] = self.scan_security_headers()
        scan_results["vulnerabilities"].extend(self.scan_sql_injection())
        scan_results["vulnerabilities"].extend(self.scan_xss())
        scan_results["vulnerabilities"].extend(self.scan_csrf())
        scan_results["vulnerabilities"].extend(self.scan_authentication())
        
        # Generate summary
        scan_results["summary"] = self._generate_scan_summary(scan_results)
        
        logger.end_test("Security Vulnerability Scan")
        return scan_results
    
    def _generate_scan_summary(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a summary of scan results"""
        total_vulns = len(scan_results["vulnerabilities"])
        critical_vulns = len([v for v in scan_results["vulnerabilities"] if v.severity == "CRITICAL"])
        high_vulns = len([v for v in scan_results["vulnerabilities"] if v.severity == "HIGH"])
        medium_vulns = len([v for v in scan_results["vulnerabilities"] if v.severity == "MEDIUM"])
        low_vulns = len([v for v in scan_results["vulnerabilities"] if v.severity == "LOW"])
        
        # Calculate security score
        base_score = 100
        score_deductions = {
            "CRITICAL": 25,
            "HIGH": 15,
            "MEDIUM": 10,
            "LOW": 5
        }
        
        security_score = base_score
        security_score -= critical_vulns * score_deductions["CRITICAL"]
        security_score -= high_vulns * score_deductions["HIGH"]
        security_score -= medium_vulns * score_deductions["MEDIUM"]
        security_score -= low_vulns * score_deductions["LOW"]
        security_score = max(0, security_score)
        
        return {
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "high_vulnerabilities": high_vulns,
            "medium_vulnerabilities": medium_vulns,
            "low_vulnerabilities": low_vulns,
            "security_score": security_score,
            "risk_level": "LOW" if security_score >= 80 else "MEDIUM" if security_score >= 60 else "HIGH"
        }


def run_security_scan(target_url: str) -> Dict[str, Any]:
    """Convenience function to run a security scan"""
    scanner = SecurityScanner(target_url)
    return scanner.run_full_scan()


def scan_all_targets() -> Dict[str, Any]:
    """Scan all configured test targets"""
    logger.start_test("Multi-Target Security Scan", "security")
    
    all_results = {}
    
    # Scan demo applications
    for app_name, app_url in TEST_TARGETS_CONFIG.DEMO_APPS.items():
        logger.info(f"Scanning demo application: {app_name}")
        try:
            scanner = SecurityScanner(app_url)
            results = scanner.run_full_scan()
            all_results[app_name] = results
        except Exception as e:
            logger.error(f"Failed to scan {app_name}: {str(e)}")
            all_results[app_name] = {"error": str(e)}
    
    # Scan API endpoints
    for api_name, api_url in TEST_TARGETS_CONFIG.API_ENDPOINTS.items():
        logger.info(f"Scanning API endpoint: {api_name}")
        try:
            scanner = SecurityScanner(api_url)
            results = scanner.run_full_scan()
            all_results[api_name] = results
        except Exception as e:
            logger.error(f"Failed to scan {api_name}: {str(e)}")
            all_results[api_name] = {"error": str(e)}
    
    logger.end_test("Multi-Target Security Scan")
    return all_results


if __name__ == "__main__":
    # Example usage
    target = "https://example.com"
    results = run_security_scan(target)
    print(json.dumps(results, indent=2))

